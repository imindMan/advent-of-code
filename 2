# the plan is to use some backtracking to solve
# | is a vertical pipe connecting north and south.
# - is a horizontal pipe connecting east and west.
# L is a 90-degree bend connecting north and east.
# J is a 90-degree bend connecting north and west.
# 7 is a 90-degree bend connecting south and west.
# F is a 90-degree bend connecting south and east.
# . is ground; there is no pipe in this tile.
# S is the starting position of the animal; there is a pipe on this tile, but your sketch doesn't show what shape the pipe has.

file = File.read_lines("day10.txt")

def move(instruction, map, x, y)
  check_length = map[0].size
  if instruction == "left" && y - 1 < 0
    return {-1, -1}
  elsif instruction == "right" && y + 1 > check_length - 1
    return {-1, -1}
  elsif instruction == "top" && x - 1 < 0
    return {-1, -1}
  elsif instruction == "bottom" && x + 1 > map.size - 1
    return {-1, -1}
  end
  case instruction
  when "left"
    case map[x][y]
    when '-', 'J', '7', 'S'
      return {x, y - 1} if ['-', 'F', 'L'].includes?(map[x][y - 1])
    end
  when "right"
    case map[x][y]
    when '-', 'F', 'L', 'S'
      return {x, y + 1} if ['-', 'J', '7'].includes?(map[x][y + 1])
    end
  when "top"
    case map[x][y]
    when '|', 'L', 'S'
      return {x - 1, y} if ['|', 'F', '7'].includes?(map[x - 1][y])
    end
  when "bottom"
    case map[x][y]
    when '|', '7', 'F', 'S'
      return {x + 1, y} if ['|', 'L', 'J'].includes?(map[x + 1][y])
    end
  end
  {-1, -1}
end

def can_still_move(map, x, y)
  ["left", "right", "top", "bottom"].any? do |instruction|
    move(instruction, map, x, y) != {-1, -1}
  end
end

def check_animal_position(map)
  row = 0
  col = 0
  while row < map.size
    while col < map[0].size
      return {row, col} if map[row][col] == 'S'
      col += 1
    end
    col = 0
    row += 1
  end
  {-1, -1}
end

def step_to_s(map, x, y)
  all_passing_characters = [] of Tuple(Int32, Int32)

  # Base case: if we are on 'S', return the valid path
  return [] of Tuple(Int32, Int32) if map[x][y] == 'S'

  # Try all possible directions
  ["left", "right", "top", "bottom"].each do |instruction|
    step = move(instruction, map, x, y)

    # Proceed if the step is valid
    if step != {-1, -1}
      # Add step to path
      all_passing_characters << step

      # Recursively try to find the rest of the path
      step_two = step_to_s(map, step[0], step[1])

      # If a valid path is found, combine the steps
      unless step_two.empty?
        return all_passing_characters + step_two
      end

      # If no valid path is found, remove the current step
      all_passing_characters.pop
    end
  end

  return all_passing_characters
end

start_pos = check_animal_position(file)
p! step_to_s(file, start_pos[0], start_pos[1])
